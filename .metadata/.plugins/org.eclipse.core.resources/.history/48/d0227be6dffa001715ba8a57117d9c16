/**
 * 
 */
package domain.task.impl;

import java.util.Date;
import java.util.List;

import domain.model.VehicleRecord;
import domain.task.FeeCalculatorTask;
import domain.utility.Constants;
import infrastructure.dao.FeeCalculatorTaskDao;

/**
 * @author juan.salazar
 *
 */
public class FeeCalculatorTaskImpl implements FeeCalculatorTask {
	
	FeeCalculatorTaskDao feeCalculatorTaskDao;

	@Override
	public Long calculateChargedFee() {
		// Get active vehicles records
		List<VehicleRecord> vehicleRecords = getActiveVehicleRecord();
		
		// Find time parked
		for (VehicleRecord record: vehicleRecords) {
			Long parkingTime = findParkingTime(record);
			Integer parkingHours = findParkingHours(parkingTime);
			Long fee = findFee(record, parkingHours);
		}
		return null;
	}
	
	private List<VehicleRecord> getActiveVehicleRecord() {
		return feeCalculatorTaskDao.getActiveVehicleRecord();
	}
	
	private Long findParkingTime(VehicleRecord record) {
		Date currentTime = new Date();
		return currentTime.getTime() - record.getTimeIn().getTime();
	}
	
	private Integer findParkingHours(Long parkingTime) {
		return (int) (parkingTime * Constants.HOURS_PER_MS);
	}
	
	private Long findFee(VehicleRecord record, Integer parkingHours) {
		Long fee = 0L;
		if (parkingHours < Constants.HOURS_FARE_LIMIT) {
			fee = findFeeByVehicleType(record, parkingHours, Constants.HOUR_RATE);
		} else if (parkingHours >= Constants.HOURS_FARE_LIMIT &&
				parkingHours < Constants.DAYS_FARE_LIMIT) {
			fee = findFeeByVehicleType(record, parkingHours, Constants.DAY_RATE);
		} else if (parkingHours >= Constants.DAYS_FARE_LIMIT) {
			fee = findFeeByVehicleType(record, parkingHours, Constants.MIXED_RATE);
		}
		
		return fee;
	}
	
	private Long findFeeByVehicleType(VehicleRecord record, Integer parkingHours, String rate) {
		Long fee = 0L;
		String vehicleType = record.getVehicle().getType();
		if (vehicleType.equals(Constants.CAR)) {
			fee = findFeeCar(parkingHours, rate);
		} else if (vehicleType.equals(Constants.MOTORCYCLE)) {
			fee = findFeeMotorcycle(parkingHours, rate, record.getCc());
		}
		return fee;
	}
	
	private Long findFeeCar(Integer parkingHours, String rate) {
		Long fee = 0L;
		switch (rate) {
		case Constants.HOUR_RATE:
			fee = (long) (parkingHours * Constants.HOUR_FARE_CAR);
			break;
		case Constants.DAY_RATE:
			fee = (long) Constants.DAY_FARE_CAR;
			break;
		case Constants.MIXED_RATE:
			break;
		}
		return fee;
	}
	
	private Long findFeeMotorcycle(Integer parkingHours, String rate, Integer cc) {
		
		if (cc > Constants.FARE_LIMIT_CC_MOTORCYCLE) {
			
		}
		
		return null;
	}
	
	private Long findMixedFee(Integer parkingHours) {
		Long fee = 0L;
		Integer days = findNumberOfDays(parkingHours);
		Integer remainingHours = findRemainingHours(parkingHours, days);
		if (remainingHours < Constants.HOURS_FARE_LIMIT) {
			fee = ((long) days * Constants.DAY_FARE_CAR) + 
					(remainingHours * Constants.HOUR_FARE_CAR);
		} else if (remainingHours >= Constants.HOURS_FARE_LIMIT) {
			
		}
		return null;
	}
	
	private Integer findNumberOfDays(Integer parkingHours) {
		return parkingHours/Constants.DAYS_FARE_LIMIT;
	}
	
	private Integer findRemainingHours(Integer parkingHours, Integer days) {
		return parkingHours - (days * Constants.DAYS_FARE_LIMIT);
	}

}
